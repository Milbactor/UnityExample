//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18449
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;


namespace AssemblyCSharp
{
	public class GeekTools
	{
		public static void GizmosDrawRect ( Vector3 pos, Rect rect ) 
		{
			/*Gizmos.DrawLine( new Vector3( rect.x ,rect.y, -10 ), new Vector3( rect.x + rect.width , rect.y, -10) );
			Gizmos.DrawLine( new Vector3( rect.x + rect.width ,rect.y, -10 ), new Vector3( rect.x + rect.width , rect.y - rect.height, -10) );
			Gizmos.DrawLine( new Vector3( rect.x + rect.width ,rect.y - rect.height, -10 ), new Vector3( rect.x + rect.width , rect.y - rect.height, -10) );
			Gizmos.DrawLine( new Vector3( rect.x ,rect.y - rect.height, -10 ), new Vector3( rect.x , rect.y, -10) ); */
			Gizmos.DrawLine( new Vector3( pos.x - (rect.width / 2 ) ,pos.y - (rect.height / 2 ), -10 ), 
			                new Vector3( pos.x + (rect.width / 2) , pos.y - (rect.height / 2 ), -10) );
			                
			Gizmos.DrawLine( new Vector3( pos.x + (rect.width / 2) , pos.y - (rect.height / 2 ), -10) ,
			                new Vector3( pos.x + (rect.width / 2) , pos.y + (rect.height / 2 ), -10) );
			                
			Gizmos.DrawLine( new Vector3( pos.x + (rect.width / 2) , pos.y + (rect.height / 2 ), -10),
			                new Vector3( pos.x - (rect.width / 2) , pos.y + (rect.height / 2 ), -10) );
			
			Gizmos.DrawLine( new Vector3( pos.x - (rect.width / 2) , pos.y + (rect.height / 2 ), -10) ,
			                new Vector3( pos.x - (rect.width / 2 ) ,pos.y - (rect.height / 2 ), -10 ) );
		}
		
		public static void Log(object message )
		{
			//Debug.Log( "[" + System.DateTime.Now.ToLongTimeString() + "] : " + message );
		}
		
		public static Vector2 AngleToVector(float angle)
		{
			return new Vector2((float)Math.Cos(angle), (float)Math.Sin(angle));
		}
		
		public static void Stun( GameObject target, int duration = 0)
		{
			StunC stun = target.AddComponent<StunC>();
			stun.duration = duration;
		}
	
		public static bool tagInRaycastHits( RaycastHit2D[] hits, string tag )
		{
			foreach( RaycastHit2D hit in hits )
			{
				if( hit.collider.tag.Equals( tag ) ) {
					return true;
				}
			}
			return false;
		}
		
		public static bool layerInRaycastHits( RaycastHit2D[] hits, string layer)
		{
			int layerInt = LayerMask.NameToLayer( layer );
			foreach( RaycastHit2D hit in hits )
			{
				if( hit.collider.gameObject.layer == layerInt ) {
					return true;
				}
			}
			return false;
		}
		
		public static bool gameobjectInRaycastHits( RaycastHit2D[] hits, GameObject obj )
		{
			foreach( RaycastHit2D hit in hits )
			{
				if( hit.collider.gameObject == obj ) {
					return true;
				}
			}
			return false;
		}
		
		public static bool nonTriggerInRaycastHits(RaycastHit2D[] hits )
		{
			foreach( RaycastHit2D hit in hits )
			{
				if( hit.collider.isTrigger == false) {
					return true;
				}
			}
			return false;
		}
		
		public static bool childInRaycastHits( RaycastHit2D[] hits, GameObject obj )
		{
		
			//Debug.Log("----------");
			foreach( RaycastHit2D hit in hits )
			{
				//Debug.Log("child in raycast : " + hit.collider.gameObject.name );
				foreach( Transform transform in obj.transform )
				{
					//Debug.Log("transform in obj.transform : " + transform.gameObject.name );
					if( transform.gameObject == hit.collider.gameObject ){
					//Debug.Log("----return true------");
						return true;
					}
				}
			}
			
			//Debug.Log("---- return false ---");
			return false;
		}
		
	}
}


//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18449
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;


namespace AssemblyCSharp
{
	public class StatusEffectManager : GeekBehaviour
	{
		public static Dictionary<Type, List<StatusEffect> > effects = new Dictionary< Type, List<StatusEffect> >();
		public static string M_REMOVE_EFFECT = "M_REMOVE_EFFECT";
		
		void Start()
		{
			base.Start();
			
			addMessageListener( (args) => RemoveEffect( (Type)args[0] ), M_REMOVE_EFFECT );
		}
		
		public void addEffect<T> () where T : StatusEffect
		{
			T dummy = Activator.CreateInstance(typeof(T)) as T;
			if( dummy.extendOnStack && GetComponent<T>() != null )
			{
				gameObject.GetComponent<T>().extend();
			}
			else
			{
				gameObject.AddComponent<T>();
			}
		}
		
		public StatusEffect getEarliestEffect( Type type )
		{
			return effects[type][0];
		}
		
		public void RemoveEffect<T> () where T : StatusEffect
		{
			int effectTypeAmount = effects[ typeof(T)] .Count; 
			if( effects[ typeof(T) ].Count > 0 )
			{
				effects[typeof(T)].RemoveAt( effectTypeAmount - 1 );
			}
			else
			{
				//print ("tring to remove effect of type : " + T + " which is not present on gameobject " + gameObject.name );
			}
		}
		
		public void RemoveEffect( Type type )
		{
			int effectTypeAmount = effects[type].Count; 
			if( effects[ type ].Count > 0 )
			{
				effects[type].RemoveAt( effectTypeAmount - 1 );
			}
			else
			{
				print ("tring to remove effect of type : " + type.Name + " which is not present on gameobject " + gameObject.name );
			}
		} 
		
		public void RemoveEffect( StatusEffect effect )
		{
			//print("succesfully removed effect " + effect + " : " + effects[ effect.GetType() ].Remove( effect ) );
			//print ("remaining effects of type " + effect.GetType().Name + " : " + effects[effect.GetType() ].Count );
		}
		
		public bool containsSameType (Type type)
		{
			return effects[ type ].Count > 1;
		}
		
		public void Register( StatusEffect status)
		{
			if( !effects.ContainsKey( status.GetType() ) ){
				effects[status.GetType()] = new List<StatusEffect>();
			}
			effects[status.GetType()].Add( status );
			status.GetComponent<MessageDispatcher>().addMessageListener( args => OnStatusEnd( (StatusEffect)args[0]), StatusEffect.M_STATUS_END );
		}
		
		//not used currently, see statuseffectC
		void OnStatusEnd (StatusEffect statusEffect)
		{
			Dictionary< STATUS_EFFECTS, bool > resetDict = new Dictionary<STATUS_EFFECTS, bool>();
			List<StatusEffect> correspondingEffects = effects[ statusEffect.GetType()];
			correspondingEffects.Remove( statusEffect );
			
			/*foreach( StatusEffect ef in effects.Values )
			{
				foreach( STATUS_EFFECTS property in ef.effectedProperties )
				{
					foreach( StatusEffect endedProperty in statusEffect.effectedProperties )
					{
						if( endedProperty == property) resetDict[property] = false;
					}
				}
			} */
			
			
		}
	}
}


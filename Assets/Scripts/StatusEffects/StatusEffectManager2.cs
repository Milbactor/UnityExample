//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18449
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;


namespace AssemblyCSharp
{
	public class StatusEffectManager2 : GeekBehaviour
	{
		public static List< int >  activePropertyEffects = new List< int >();
		public static Dictionary<int, List<StatusEffect> > statusEffects = new Dictionary< int, List<StatusEffect> >();
		
		/*public static string M_REMOVE_EFFECT = "M_REMOVE_EFFECT";
		
		void Start()
		{
			base.Start();
			
			addMessageListener( (args) => RemoveEffect( (Type)args[0] ), M_REMOVE_EFFECT );
		}
		
		public void addEffect<T> () where T : StatusEffect2
		{
			T dummy = Activator.CreateInstance(typeof(T)) as T;
			if( dummy.extendWhenStack && GetComponent<T>() != null )
			{
				gameObject.GetComponent<T>().extend();
			}
			else
			{
				gameObject.AddComponent<T>();
			}
		}
		
		public StatusEffect getEarliestEffect( int property )
		{
			foreach( StatusEffect effect in statusEffects[ property] )
			{
				foreach( int p in effect.propertyValues )
				{
					if( p == property) return effect;
				}
			}
		}
		
		public void RemoveEffect<T> () where T : StatusEffect2
		{
			int effectTypeAmount = statusEffects[ typeof(T)] .Count; 
			if( statusEffects[ typeof(T) ].Count > 0 )
			{
				statusEffects[typeof(T)].RemoveAt( effectTypeAmount - 1 );
			}
			else
			{
				//print ("tring to remove effect of type : " + T + " which is not present on gameobject " + gameObject.name );
			}
		}
		
		public void RemoveEffect( StatusEffect2 effect )
		{
			print("succesfully removed effect " + effect + " : " + statusEffects[ effect.GetType() ].Remove( effect ) );
			print ("remaining effects of type " + effect.GetType().Name + " : " + statusEffects[effect.GetType() ].Count );
		}
		
		//meant to be overriden
		protected virtual void resetValue( int property )
		{
			
		}
		
		
		public void Register( StatusEffect2 status)
		{
			foreach(int effectedProperty in status.propertyValues.Keys )
			{
				if( statusEffects[effectedProperty] == null ) StatusEffect2[effectedProperty] = new List<StatusEffect2>();
			}
			status.GetComponent<MessageDispatcher>().addMessageListener( args => OnStatusEnd( (StatusEffect2)args[0]), StatusEffect2.M_STATUS_END );
		}
		
		//not used currently, see statuseffectC
		void OnStatusEnd (StatusEffect2 statusEffect)
		{
			
		} */
	}
}

